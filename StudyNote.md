# C专家编程

## 第一章 C:穿越时空的迷雾

///

## 第二章 这不是Bug，而是语言特性

///

## 第三章 分析C语言的声明

### 1.用优先级解决声明问题

#### 1.1 优先级规则

```c
A	从名字开始读取，按照优先级顺序读取
B	优先级从高到低：
	B.1	声明中被括号括起来的部分
	B.2 后缀操作符：
		() → 函数
		[] → 数组
    B.3 前缀操作符：
    	* → 指向...的指针
C	const和（或）volatile关键字后紧跟类型说明符（int 、long），那么它作用于
	类型说明符。其他情况，const和（或）volatile作用于它左边紧邻的指针*。
```



### 2.typedef

**typedef**：为一种类型引入新的名字，而不是为变量分配空间，类似于宏文本替换。

##### 2.2 typedef .vs. #define

- 宏类型名扩展；
- 连续变量声明中，typedef定义类型可以保证变量均为同一类型，#define定义类型不能；

```c
#define peach int
#define mapv 1000	//classical usage
typedef int banana;

unsigned peach b = 7; 	// √
unsigned banana c = 3;	// error!
    
```



## 第四章 令人震惊的事实：数组和指针并不相同

### 1.声明和定义

C语言中有且仅有一个定义，但可以有多个`extern`声明。

|  1   |             2              |                              3                               |
| :--: | :------------------------: | :----------------------------------------------------------: |
| 定义 | 只能出现在一个地方（一次） |  确定对象的类型并分配内存，用于创建新的对象：int value=10;   |
| 声明 |     可以出现在多个地方     | 描述对象的类型，用于指代其他地方定义的对象：extern int value |

### 2.指针和数组的差异

```c
char * p; // p是一个指针，指针指向的内存存储的是指针的内容
char tp[];// tp自身就是地址
```

相比较于数组，指针的操作需要多一个取地址的过程。



## 第五章 对链接的思考

### 1.动态链接& 静态链接

### 1.1 定义

函数库的拷贝，是可执行文件的物理组成部分，则称为静态链接。

可执行文件只包含文件名，载入器在运行是寻找可执行文件，则称为动态链接。

```c
*.a //a = archive，静态链接库
*.so // shared object 动态链接库
```

​	收集模块准备执行三阶段：链接-编辑（link-editing）、载入（loading）、运行时链接（runtime linking）。静态链接的模块被链接-编辑并载入以便运行。动态链接的模块被链接编辑后载入，并在运行时进行链接以便运行。

### 1.2 ABI

​	动态链接的目的是将程序与其所用的特定函数库版本分离。介于应用程序和函数库二进制可执行文件所提供的服务之间的接口，称之为应用二进制接口（Application Binary Interface,ABI）。

### 1.3 链接器（Linker）

​	编译器创建一个输出文件，这个文件包含可以重定向的对象。这些对象就是与源程序对应的数据和机器指令。

### 1.4 编译器（Compiler)

​	编译器包括（Compiler）：预处理器（Preprocessor）、语法和语义检查器（syntactic and semantic checker）、代码生成器（code generator）、汇编程序（assembler）、优化器（optimizer）、链接器（linker）。

```CQL
-# // 查看编译过程的各个独立阶段
-V // 查看版本信息

```



​	目标文件不能直接执行，需要载入到链接器中。链接器确认main函数为初始进入点，把符号引用（Symbolic Reference）绑定到内存地址，再把所有的目标文件集中在一起，加上库文件，从何产生可执行文件。



## 第六章 运动的诗章：运行时数据结构

### 6.1.a.out

a.out（Assembler Output）汇编输出，实际是连接器输出；

### 2.IntelX86和 Unix段（Segment）的区别

Intelx86中，内存模型设计为64kb大小的模块，一个模块就是一个段。

Unix表示一个二进制文件相关的块；

### 3.Unix 段内容

 Unix段：数据段、bbs段、文本段；

### 6.5 当函数被调用时发生了什么：过程活动记录

1.C语言自动提供的服务—跟踪调用链（哪些函数调用了哪些函数），当下一个return语句执行之后，控制将返回何处。

## 第九章 再论数组

### 9.1 什么时候数组与指针相同

​	实际应用中，数组和指针可以互换的场景比不能互换的场景多。

数组三种声明情况：

- 外部数组（external array）声明；
- 数组的定义（定义是声明的一种特殊情景，分配内存提供初始值）；
- 函数参数的声明；

`所有作为函数参数的数组名总是可以通过编译器转换为指针。`对编译器而言，一个数组就是地址，一个指针是地址的地址。



```c
int narrays[]  = {0,1,2,3};
int arraySize =sizeof(narrays)/sizeof(narrays[0]); // arraySize = 4;

```

**2.数组和指针（不）相同**

```c
/*
不同
*/
// 外部声明
extern char a[10];
// 定义
char a[10];

/*
相同
*/
// 函数形参
void function(char a_[]);
void function_1(char* a_);

// 表达式中使用
char b = a[0];
char b = *(a + index);
```

**3.数组引用**

**规则1：** 表达式中的数组名就是指针

```c
// 对数组的引用a[i]被编译器翻译成*(p+i)
int na[10]={0};
int *pna = na;
int nvalue = na[i];
nvalue == *(pna+i);

```

取下标操作符`[]` 自动将步长调整到数组元素的大小，这就是为什么不使用**sizeof**的原因。

取下标操作符`a[10]` 表示结果和 `10[a]` 相同。



**规则2：** C语言把数组下标作为指针的偏移量

不同方式访问速度问题；

**规则3：** 作为函数参数的数组名等同于指针

| 术语              | 定义                                                         |
| ----------------- | ------------------------------------------------------------ |
| 形参（parameter） | 它是一个变量，在函数定义或函数声明原型中定义，又称为形式参数（formal parameter） |
| 实参（argument）  | 它是一个值，在函数调用时传递给函数的值，又称实际参数（actual parameter） |

编译器只能向函数传递数组的指针而不是整个数组的拷贝。

### 9.6 C语言的多维数组

定义和引用多维数组的唯一方式就是使用多维数组。

```c
// 定义 → 访问 
typedef char Vegetable[20];
Vegetable bo[10];
b0[i][j]= *(*(bo+i)  + j )
```

**数组的数组。**



## 第十章 再论指针

#### 1.多维数组内存分配

内存是线性排列方式，不是表分配方式。

#### 2.指针数组就是Iliffe向量

通过声明一个一维指针数组，每个指针指向一个字符串来获取二维数组的效果。

```c
//sqush[i][j] 可能声明形式
int sqush[4][5]; // int型 二维数组
int *sqush[4]; // int 类型指针的数组Iliffe向量
int **sqush;	// int 类型执行指针的指针
int (*sqush)[5];// 类型为int数组（长度为5）的指针
```

#### 3.锯齿状数组上使用指针



#### 4.向函数传递一个一维数组







# 利用Python进行数据分析

## 第一章 准备工作

### 1.重要Python库

|    Lib     | Discription                                  |
| :--------: | -------------------------------------------- |
|   Numpy    | 科学计算基础包                               |
|   pandas   | 快速便捷地处理结构化数据的大量数据结构和函数 |
| matplotlib | 用于绘制数据图表的Python库                   |
|   SciPy    | 专门解决科学计算中各种标准问题域的包的集合   |
|    ...     | ...                                          |



## 第二章 ipython

```python
"""
	开发环境：python3.7 + anaconda + vs Code + spyder
"""
```

加强版ipython 不是最好的解决方案。





