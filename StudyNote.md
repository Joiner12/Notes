# C专家编程

## 第一章 C:穿越时空的迷雾

///

## 第二章 这不是Bug，而是语言特性

///

## 第三章 分析C语言的声明

### 1.用优先级解决声明问题

#### 1.1 优先级规则

```c
A	从名字开始读取，按照优先级顺序读取
B	优先级从高到低：
	B.1	声明中被括号括起来的部分
	B.2 后缀操作符：
		() → 函数
		[] → 数组
    B.3 前缀操作符：
    	* → 指向...的指针
C	const和（或）volatile关键字后紧跟类型说明符（int 、long），那么它作用于
	类型说明符。其他情况，const和（或）volatile作用于它左边紧邻的指针*。
```



### 2.typedef

**typedef**：为一种类型引入新的名字，而不是为变量分配空间，类似于宏文本替换。

##### 2.2 typedef .vs. #define

- 宏类型名扩展；
- 连续变量声明中，typedef定义类型可以保证变量均为同一类型，#define定义类型不能；

```c
#define peach int
#define mapv 1000	//classical usage
typedef int banana;

unsigned peach b = 7; 	// √
unsigned banana c = 3;	// error!
    
```



## 第四章 令人震惊的事实：数组和指针并不相同

### 1.声明和定义

C语言中有且仅有一个定义，但可以有多个`extern`声明。

|  1   |             2              |                              3                               |
| :--: | :------------------------: | :----------------------------------------------------------: |
| 定义 | 只能出现在一个地方（一次） |  确定对象的类型并分配内存，用于创建新的对象：int value=10;   |
| 声明 |     可以出现在多个地方     | 描述对象的类型，用于指代其他地方定义的对象：extern int value |

### 2.指针和数组的差异

```c
char * p; // p是一个指针，指针指向的内存存储的是指针的内容
char tp[];// tp自身就是地址
```

相比较于数组，指针的操作需要多一个取地址的过程。



## 第五章 对链接的思考

### 1.动态链接& 静态链接

### 1.1 定义

函数库的拷贝，是可执行文件的物理组成部分，则称为静态链接。

可执行文件只包含文件名，载入器在运行是寻找可执行文件，则称为动态链接。

```c
*.a //a = archive，静态链接库
*.so // shared object 动态链接库
```

​	收集模块准备执行三阶段：链接-编辑（link-editing）、载入（loading）、运行时链接（runtime linking）。静态链接的模块被链接-编辑并载入以便运行。动态链接的模块被链接编辑后载入，并在运行时进行链接以便运行。

### 1.2 ABI

​	动态链接的目的是将程序与其所用的特定函数库版本分离。介于应用程序和函数库二进制可执行文件所提供的服务之间的接口，称之为应用二进制接口（Application Binary Interface,ABI）。

### 1.3 链接器（Linker）

​	编译器创建一个输出文件，这个文件包含可以重定向的对象。这些对象就是与源程序对应的数据和机器指令。

### 1.4 编译器（Compiler)

​	编译器包括（Compiler）：预处理器（Preprocessor）、语法和语义检查器（syntactic and semantic checker）、代码生成器（code generator）、汇编程序（assembler）、优化器（optimizer）、链接器（linker）。

```CQL
-# // 查看编译过程的各个独立阶段
-V // 查看版本信息

```



​	目标文件不能直接执行，需要载入到链接器中。链接器确认main函数为初始进入点，把符号引用（Symbolic Reference）绑定到内存地址，再把所有的目标文件集中在一起，加上库文件，从何产生可执行文件。



## 第六章 运动的诗章：运行时数据结构

### 6.1.a.out

a.out（Assembler Output）汇编输出，实际是连接器输出；

### 2.IntelX86和 Unix段（Segment）的区别

Intelx86中，内存模型设计为64kb大小的模块，一个模块就是一个段。

Unix表示一个二进制文件相关的块；

### 3.Unix 段内容

 Unix段：数据段、bbs段、文本段；

### 6.5 当函数被调用时发生了什么：过程活动记录

1.C语言自动提供的服务—跟踪调用链（哪些函数调用了哪些函数），当下一个return语句执行之后，控制将返回何处。

## 第九章 再论数组

### 9.1 什么时候数组与指针相同

​	实际应用中，数组和指针可以互换的场景比不能互换的场景多。

数组三种声明情况：

- 外部数组（external array）声明；
- 数组的定义（定义是声明的一种特殊情景，分配内存提供初始值）；
- 函数参数的声明；

`所有作为函数参数的数组名总是可以通过编译器转换为指针。`对编译器而言，一个数组就是地址，一个指针是地址的地址。



```c
int narrays[]  = {0,1,2,3};
int arraySize =sizeof(narrays)/sizeof(narrays[0]); // arraySize = 4;

```

